<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Griffin Viewer with Advanced Effects</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@600&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', sans-serif;
        }
        canvas {
            width: 100%;
            height: 100vh;
            display: block;
        }
        #ui-container {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            text-align: center;
        }
        #effect-trigger {
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: background 0.3s, color 0.3s, transform 0.2s;
        }
        #effect-trigger:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }
        #effect-trigger:active {
            transform: scale(0.95);
        }
        #effect-info {
            margin-top: 10px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <button id="effect-trigger">Trigger Effect</button>
        <div id="effect-info">Lightning Storm</div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // ## 1. Scene Setup ##
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 2, 8);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(0, 1, 0);
    controls.update();

    // ## 2. Post-Processing ##
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloomPass.strength = 1.2; // Start with a subtle bloom
    composer.addPass(bloomPass);

    // ## 3. Effect Management ##
    let effectState = 0;
    const clock = new THREE.Clock();
    let modelCenter = new THREE.Vector3();
    let modelSize = new THREE.Vector3();

    const effectThemes = [
        { name: "Lightning Storm", effect: "lightning" },
        { name: "Volcanic Shards", effect: "shards", shardColors: [new THREE.Color(0xff8c00), new THREE.Color(0xffa500), new THREE.Color(0xffff00)] },
        { name: "Arctic Rings", effect: "rings", ringColors: [new THREE.Color(0x00ffff), new THREE.Color(0x87ceeb), new THREE.Color(0xffffff)] },
        { name: "Emerald Spiral", effect: "spiral", spiralColors: [new THREE.Color(0x00ff00), new THREE.Color(0x32cd32), new THREE.Color(0xadff2f)] },
        { name: "Solar Flare", effect: "flare", flareColors: [new THREE.Color(0xff4500), new THREE.Color(0xff6600), new THREE.Color(0xffa500), new THREE.Color(0xffff00), new THREE.Color(0xffd700)] }
    ];

    const effectGroups = {
        lightning: new THREE.Group(), shards: new THREE.Group(), rings: new THREE.Group(), spiral: new THREE.Group(), flare: new THREE.Group()
    };
    scene.add(...Object.values(effectGroups));
    
    const effectData = {
        lightning: { isActive: false, startTime: 0, duration: 1.0 },
        shards: { isActive: false }, rings: { isActive: false }, spiral: { isActive: false }, flare: { isActive: false }
    };

    // ## 4. Model Loading ##
    const loader = new GLTFLoader();
    loader.load('griffin.glb', (gltf) => {
        const model = gltf.scene;
        // Center and scale model
        const box = new THREE.Box3().setFromObject(model);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 5 / maxDim;
        model.scale.set(scale, scale, scale);
        model.position.sub(center.multiplyScalar(scale));
        scene.add(model);
        // Store model dimensions for effects
        const modelBox = new THREE.Box3().setFromObject(model);
        modelSize.copy(modelBox.getSize(new THREE.Vector3()));
        modelCenter.copy(modelBox.getCenter(new THREE.Vector3()));
        controls.target.copy(modelCenter);
    });

    // ## 5. Effect Creation Functions ##
    const lightningMaterial = new THREE.ShaderMaterial({
        uniforms: { uTime: { value: 0 }, uLife: { value: 0 }, uFlicker: { value: 1.0 } },
        vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
        fragmentShader: `uniform float uTime, uLife, uFlicker; varying vec2 vUv; float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453); } float noise(vec2 st) { vec2 i = floor(st), f = fract(st); float a = random(i), b = random(i + vec2(1,0)), c = random(i + vec2(0,1)), d = random(i + vec2(1,1)); vec2 u = f*f*(3.0-2.0*f); return mix(a,b,u.x) + (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y; } void main() { float core = smoothstep(0.4, 0.0, abs(vUv.x - 0.5)); core += noise(vec2(vUv.y*40.0, uTime*2.0)) * noise(vec2(vUv.y*25.0, uTime*1.5)) * 0.8; vec3 color = mix(vec3(0.1,0.5,1.0), vec3(0.6,0.2,1.0), core*0.7); color = mix(color, vec3(1.0), pow(core, 2.0)*0.9); float lifeAlpha = smoothstep(0.0, 0.2, uLife) * (1.0 - smoothstep(0.6, 1.0, uLife)); float intense = sin(uLife * 3.14159 * 3.0) * 0.5 + 0.5; float alpha = pow(1.0 - abs(vUv.x - 0.5)*2.0, 2.0) * lifeAlpha * uFlicker * intense; gl_FragColor = vec4(color, alpha); }`,
        transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
    });

    function triggerShardBurst(colors) {
        if (effectGroups.shards.children.length) return;
        effectData.shards.isActive = true;
        const origin = modelCenter.clone();
        for (let i = 0; i < 300; i++) {
            const geo = new THREE.ConeGeometry(0.015, 0.5, 4);
            const mat = new THREE.MeshBasicMaterial({ color: colors[Math.floor(Math.random() * colors.length)], blending: THREE.AdditiveBlending, transparent: true });
            const shard = new THREE.Mesh(geo, mat);
            shard.position.copy(origin);
            const dir = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
            shard.lookAt(dir.clone().add(origin));
            shard.rotateX(Math.PI / 2);
            shard.userData.velocity = dir.multiplyScalar(0.08 + Math.random() * 0.12);
            shard.userData.life = 1.0;
            effectGroups.shards.add(shard);
        }
    }

    function triggerRings(colors) {
        if (effectGroups.rings.children.length) return;
        effectData.rings.isActive = true;
        const origin = modelCenter.clone();
        for (let r = 0; r < 5; r++) {
            const ringGeo = new THREE.RingGeometry(1.5 + r * 0.3, 1.6 + r * 0.3, 64);
            const mat = new THREE.MeshBasicMaterial({ color: colors[r % colors.length], transparent: true, blending: THREE.AdditiveBlending, side: THREE.DoubleSide });
            const ring = new THREE.Mesh(ringGeo, mat);
            ring.position.copy(origin);
            ring.rotation.x = Math.PI / 2;
            ring.userData.speed = 0.03 + r * 0.02;
            ring.userData.life = 1.0;
            effectGroups.rings.add(ring);
        }
    }

    function triggerSpiral(colors) {
        if (effectGroups.spiral.children.length) return;
        effectData.spiral.isActive = true;
        const origin = modelCenter.clone();
        for (let i = 0; i < 200; i++) {
            const geo = new THREE.SphereGeometry(0.04, 8, 6);
            const mat = new THREE.MeshBasicMaterial({ color: colors[i % colors.length], blending: THREE.AdditiveBlending, transparent: true });
            const p = new THREE.Mesh(geo, mat);
            const angle = (i / 200) * Math.PI * 8;
            const radius = 0.1 + (i / 200) * modelSize.x * 1.5;
            p.position.set(Math.cos(angle) * radius + origin.x, origin.y + (i / 200) * modelSize.y, Math.sin(angle) * radius + origin.z);
            p.userData.angle = angle;
            p.userData.radius = radius;
            p.userData.life = 1.0;
            p.userData.speed = 0.05;
            effectGroups.spiral.add(p);
        }
    }

    function triggerFlare(colors) {
        if (effectGroups.flare.children.length) return;
        effectData.flare.isActive = true;
        const origin = modelCenter.clone().add(new THREE.Vector3(0, modelSize.y / 2, 0)); // Start from top
        for (let i = 0; i < 200; i++) {
            const geo = new THREE.PlaneGeometry(0.08 + Math.random() * 0.04, 0.4 + Math.random() * 0.3);
            const mat = new THREE.MeshBasicMaterial({ color: colors[Math.floor(Math.random() * colors.length)], transparent: true, blending: THREE.AdditiveBlending });
            const f = new THREE.Mesh(geo, mat);
            f.position.copy(origin);
            const dir = new THREE.Vector3((Math.random() - 0.5) * 2, -Math.random() * 0.8, (Math.random() - 0.5) * 2).normalize();
            f.lookAt(dir.clone().add(f.position));
            f.userData.velocity = dir.multiplyScalar(0.05 + Math.random() * 0.10);
            f.userData.life = 1.0;
            effectGroups.flare.add(f);
        }
    }

    function createCylinder(start, end, radius) {
        const dir = new THREE.Vector3().subVectors(end, start);
        const orient = new THREE.Matrix4().lookAt(start, end, new THREE.Object3D().up);
        const rot = new THREE.Matrix4().makeRotationX(Math.PI * 0.5);
        orient.multiply(rot);
        const geo = new THREE.CylinderGeometry(radius, radius, dir.length(), 8, 1, true);
        geo.applyMatrix4(orient);
        geo.translate((start.x + end.x) / 2, (start.y + end.y) / 2, (start.z + end.z) / 2);
        return geo;
    }

    function createEnhancedLightningBolt() {
        // Clear previous lightning
        effectGroups.lightning.children.forEach(c => { if(c.isMesh) { c.geometry.dispose(); c.material.dispose(); } });
        effectGroups.lightning.clear();

        const origin = modelCenter.clone().add(new THREE.Vector3(0, modelSize.y / 2 + 0.5, 0)); // Start from top of model

        function branch(start, dir, energy, depth) {
            if (energy < 0.3 || depth > 15) return;
            const len = (Math.random() * 0.7 + 0.3) * energy * 0.6;
            const end = start.clone().add(dir.clone().multiplyScalar(len));
            const rad = 0.005 + (energy / 120) + Math.random() * 0.005;
            const seg = createCylinder(start, end, rad);
            const mesh = new THREE.Mesh(seg, lightningMaterial.clone());
            effectGroups.lightning.add(mesh);
            
            const nextE = energy * (0.85 + Math.random() * 0.1);
            const nextDir = dir.clone().add(new THREE.Vector3((Math.random() - 0.5) * 4.5, (Math.random() - 0.5) * 2.5, (Math.random() - 0.5) * 4.5)).normalize();
            branch(end, nextDir, nextE, depth + 1);

            if (Math.random() < 0.6 && depth > 0) {
                const bDir = new THREE.Vector3((Math.random() - 0.5) * 6.0, (Math.random() - 0.5) * 4.0, (Math.random() - 0.5) * 6.0).normalize();
                branch(end, bDir, nextE * 0.7, depth + 1);
            }
        }
        const n = Math.floor(Math.random() * 4) + 7;
        for (let i = 0; i < n; i++) {
            const d = new THREE.Vector3((Math.random() - 0.5) * 3.5, - (Math.random() * 0.7 + 0.3), (Math.random() - 0.5) * 3.5).normalize();
            branch(origin, d, 7, 0);
        }
    }

    // ## 6. UI Interaction ##
    document.getElementById('effect-trigger').addEventListener('click', () => {
        if (Object.values(effectData).some(d => d.isActive)) return;
        
        const theme = effectThemes[effectState];
        document.getElementById('effect-info').textContent = theme.name;
        
        const originalBloomStrength = 1.2;
        let tempBloomStrength = originalBloomStrength;
        
        switch (theme.effect) {
            case 'lightning':
                createEnhancedLightningBolt();
                effectData.lightning.isActive = true;
                effectData.lightning.startTime = clock.getElapsedTime();
                tempBloomStrength = 4.5;
                break;
            case 'shards':
                triggerShardBurst(theme.shardColors);
                tempBloomStrength = 5.5;
                break;
            case 'rings':
                triggerRings(theme.ringColors);
                tempBloomStrength = 4.0;
                break;
            case 'spiral':
                triggerSpiral(theme.spiralColors);
                tempBloomStrength = 3.5;
                break;
            case 'flare':
                triggerFlare(theme.flareColors);
                tempBloomStrength = 5.5;
                break;
        }

        bloomPass.strength = tempBloomStrength;
        setTimeout(() => { bloomPass.strength = originalBloomStrength; }, 600);
        
        effectState = (effectState + 1) % effectThemes.length;
        // Pre-update the text for the next click
        document.getElementById('effect-trigger').textContent = `Next: ${effectThemes[effectState].name}`;
    });
    // Set initial button text
    document.getElementById('effect-trigger').textContent = `Next: ${effectThemes[1].name}`;


    // ## 7. Animation Loop & Effect Updates ##
    function animate() {
        requestAnimationFrame(animate);
        const et = clock.getElapsedTime();
        
        if (effectData.lightning.isActive) {
            const life = (et - effectData.lightning.startTime) / effectData.lightning.duration;
            effectGroups.lightning.traverse(c => {
                if (c.isMesh && c.material.uniforms) {
                    c.material.uniforms.uTime.value = et;
                    c.material.uniforms.uLife.value = life;
                    c.material.uniforms.uFlicker.value = Math.random() > 0.05 ? 1.0 : 0.0;
                }
            });
            if (life >= 1.0) effectData.lightning.isActive = false;
        }

        if (effectData.shards.isActive) {
            if (!effectGroups.shards.children.length) { effectData.shards.isActive = false; }
            for (let i = effectGroups.shards.children.length - 1; i >= 0; i--) {
                const s = effectGroups.shards.children[i];
                s.position.add(s.userData.velocity);
                s.userData.life -= 0.015;
                s.material.opacity = s.userData.life;
                if (s.userData.life <= 0) { s.geometry.dispose(); s.material.dispose(); effectGroups.shards.remove(s); }
            }
        }
        
        if (effectData.rings.isActive) {
            if (!effectGroups.rings.children.length) { effectData.rings.isActive = false; }
            for (let i = effectGroups.rings.children.length - 1; i >= 0; i--) {
                const r = effectGroups.rings.children[i];
                r.scale.addScalar(r.userData.speed);
                r.userData.life -= 0.01;
                r.material.opacity = r.userData.life;
                if (r.userData.life <= 0) { r.geometry.dispose(); r.material.dispose(); effectGroups.rings.remove(r); }
            }
        }

        if (effectData.spiral.isActive) {
            if (!effectGroups.spiral.children.length) { effectData.spiral.isActive = false; }
            for (let i = effectGroups.spiral.children.length - 1; i >= 0; i--) {
                const p = effectGroups.spiral.children[i];
                p.userData.angle += p.userData.speed;
                p.userData.radius += 0.02;
                p.position.x = Math.cos(p.userData.angle) * p.userData.radius + modelCenter.x;
                p.position.z = Math.sin(p.userData.angle) * p.userData.radius + modelCenter.z;
                p.position.y += 0.03;
                p.userData.life -= 0.008;
                p.material.opacity = p.userData.life;
                if (p.userData.life <= 0) { p.geometry.dispose(); p.material.dispose(); effectGroups.spiral.remove(p); }
            }
        }

        if (effectData.flare.isActive) {
            if (!effectGroups.flare.children.length) { effectData.flare.isActive = false; }
            for (let i = effectGroups.flare.children.length - 1; i >= 0; i--) {
                const f = effectGroups.flare.children[i];
                f.position.add(f.userData.velocity);
                f.userData.velocity.y -= 0.0008;
                f.userData.life -= 0.010;
                f.material.opacity = f.userData.life * (0.85 + Math.sin(et * 15 + i * 0.5) * 0.15);
                if (f.userData.life <= 0) { f.geometry.dispose(); f.material.dispose(); effectGroups.flare.remove(f); }
            }
        }
        
        controls.update();
        composer.render();
    }
    animate();

    // ## 8. Window Resize ##
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    });

    </script>
</body>
</html>
