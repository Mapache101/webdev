<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Griffin Viewer with Advanced Effects</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@600&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', sans-serif;
        }
        canvas {
            width: 100%;
            height: 100vh;
            display: block;
        }
        #ui-container {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            text-align: center;
        }
        #effect-trigger {
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: background 0.3s, color 0.3s, transform 0.2s;
        }
        #effect-trigger:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }
        #effect-trigger:active {
            transform: scale(0.95);
        }
        #effect-info {
            margin-top: 10px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <button id="effect-trigger">Next: Lightning Storm</button>
        <div id="effect-info"></div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // ## 1. Scene Setup ##
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 2, 8);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(0, 1, 0); // Default target, will be updated by model's center
    controls.update();

    // ## New: Basic Scene Lighting ##
    // Ambient Light: Soft, non-directional light that illuminates all objects equally.
    // Prevents purely black shadows and makes the model generally visible.
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3); // Soft white light, 30% intensity
    scene.add(ambientLight);

    // Directional Light: Mimics sunlight, casting light from a specific direction.
    // Creates highlights and shadows, giving the model definition.
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7); // White light, 70% intensity
    directionalLight.position.set(5, 10, 7.5); // Position the light source
    scene.add(directionalLight);


    // ## 2. Post-Processing ##
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloomPass.strength = 1.2; // Start with a subtle bloom
    composer.addPass(bloomPass);

    // ## 3. Effect Management ##
    let effectState = 0;
    const clock = new THREE.Clock();
    let modelCenter = new THREE.Vector3();
    let modelSize = new THREE.Vector3();

    const effectThemes = [
        { name: "Lightning Storm", effect: "lightning" },
        { name: "Volcanic Shards", effect: "shards", shardColors: [new THREE.Color(0xff8c00), new THREE.Color(0xffa500), new THREE.Color(0xffff00)] },
        { name: "Arctic Rings", effect: "rings", ringColors: [new THREE.Color(0x00ffff), new THREE.Color(0x87ceeb), new THREE.Color(0xffffff)] },
        { name: "Emerald Spiral", effect: "spiral", spiralColors: [new THREE.Color(0x00ff00), new THREE.Color(0x32cd32), new THREE.Color(0xadff2f)] },
        { name: "Solar Flare", effect: "flare", flareColors: [new THREE.Color(0xff4500), new THREE.Color(0xff6600), new THREE.Color(0xffa500), new THREE.Color(0xffff00), new THREE.Color(0xffd700)] }
    ];

    const effectGroups = {
        lightning: new THREE.Group(), shards: new THREE.Group(), rings: new THREE.Group(), spiral: new THREE.Group(), flare: new THREE.Group()
    };
    scene.add(...Object.values(effectGroups));
    
    const effectData = {
        lightning: { isActive: false, startTime: 0, duration: 1.0 },
        shards: { isActive: false }, rings: { isActive: false }, spiral: { isActive: false }, flare: { isActive: false }
    };

    // ## 4. Model Loading ##
    const loader = new GLTFLoader();
    loader.load('griffin.glb', (gltf) => {
        const model = gltf.scene;
        // Center and scale model
        const box = new THREE.Box3().setFromObject(model);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 5 / maxDim;
        model.scale.set(scale, scale, scale);
        model.position.sub(center.multiplyScalar(scale));
        scene.add(model);
        // Store model dimensions for effects
        const modelBox = new THREE.Box3().setFromObject(model);
        modelSize.copy(modelBox.getSize(new THREE.Vector3()));
        modelCenter.copy(modelBox.getCenter(new THREE.Vector3()));
        controls.target.copy(modelCenter); // Point camera controls to the model's center
    });

    // ## 5. Effect Creation Functions ##
    const lightningMaterial = new THREE.ShaderMaterial({
        uniforms: { uTime: { value: 0 }, uLife: { value: 0 }, uFlicker: { value: 1.0 } },
        vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
        fragmentShader: `uniform float uTime, uLife, uFlicker; varying vec2 vUv; float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453); } float noise(vec2 st) { vec2 i = floor(st), f = fract(st); float a = random(i), b = random(i + vec2(1,0)), c = random(i + vec2(0,1)), d = random(i + vec2(1,1)); vec2 u = f*f*(3.0-2.0*f); return mix(a,b,u.x) + (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y; } void main() { float core = smoothstep(0.4, 0.0, abs(vUv.x - 0.5)); core += noise(vec2(vUv.y*40.0, uTime*2.0)) * noise(vec2(vUv.y*25.0, uTime*1.5)) * 0.8; vec3 color = mix(vec3(0.1,0.5,1.0), vec3(0.6,0.2,1.0), core*0.7); color = mix(color, vec3(1.0), pow(core, 2.0)*0.9); float lifeAlpha = smoothstep(0.0, 0.2, uLife) * (1.0 - smoothstep(0.6, 1.0, uLife)); float intense = sin(uLife * 3.14159 * 3.0) * 0.5 + 0.5; float alpha = pow(1.0 - abs(vUv.x - 0.5)*2.0, 2.0) * lifeAlpha * uFlicker * intense; gl_FragColor = vec4(color, alpha); }`,
        transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
    });

    function triggerShardBurst(colors) {
        if (effectGroups.shards.children.length) return;
        effectData.shards.isActive = true;
        const origin = modelCenter.clone();
        for (let i = 0; i < 300; i++) {
            const geo = new THREE.ConeGeometry(0.015, 0.5, 4);
            const mat = new THREE.MeshBasicMaterial({ color: colors[Math.floor(Math.random() * colors.length)], blending: THREE.AdditiveBlending, transparent: true });
            const shard = new THREE.Mesh(geo, mat);
            shard.position.copy(origin);
            const dir = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
            shard.lookAt(dir.clone().add(origin));
            shard.rotateX(Math.PI / 2);
            shard.userData.velocity = dir.multiplyScalar(0.08 + Math.random() * 0.12);
            shard.userData.life = 1.0;
            effectGroups.shards.add(shard);
        }
    }

    function triggerRings(colors) {
        if (effectGroups.rings.children.length) return;
        effectData.rings.isActive = true;
        const origin = modelCenter.clone();
        for (let r = 0; r < 5; r++) {
            const ringGeo = new THREE.RingGeometry(1.5 + r * 0.3, 1.6 + r * 0.3, 64);
            const mat = new THREE.MeshBasicMaterial({ color: colors[r % colors.length], transparent: true, blending: THREE.AdditiveBlending, side: THREE.DoubleSide });
            const ring = new THREE.Mesh(ringGeo, mat);
            ring.position.copy(origin);
            ring.rotation.x = Math.PI / 2;
            ring.userData.speed = 0.03 + r * 0.02;
            ring.userData.life = 1.0;
            effectGroups.rings.add(ring);
        }
    }

    function triggerSpiral(colors) {
        if (effectGroups.spiral.children.length) return;
        effectData.spiral.isActive = true;
        const origin = modelCenter.clone();
        for (let i = 0; i < 200; i++) {
            const geo = new THREE.SphereGeometry(0.04, 8, 6);
            const mat = new THREE.MeshBasicMaterial({ color: colors[i % colors.length], blending: THREE.AdditiveBlending, transparent: true });
            const p = new THREE.Mesh(geo, mat);
            const angle = (i / 200) * Math.PI * 8;
            const radius = 0.1 + (i / 200) * modelSize.x * 1.5;
            p.position.set(Math.cos(angle) * radius + origin.x, origin.y + (i / 200) * modelSize.y, Math.sin(angle) * radius + origin.z);
            p.userData.angle = angle;
            p.userData.radius = radius;
            p.
