<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Particle Pyramid</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@600&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', sans-serif;
        }
        canvas {
            width: 100%;
            height: 100vh;
            display: block;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #ui-container {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            text-align: center;
        }
        #effect-trigger {
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: background 0.3s, color 0.3s, transform 0.2s;
        }
        #effect-trigger:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }
        #effect-trigger:active {
            transform: scale(0.95);
        }
        #effect-info {
            margin-top: 10px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <button id="effect-trigger">Trigger Effect</button>
        <div id="effect-info">Lightning Storm</div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    camera.position.set(0, 2, 6);
    controls.target.set(0, 1, 0);
    controls.update();

    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloomPass.threshold = 0.1;
    bloomPass.strength = 2.5;
    bloomPass.radius = 0.8;
    composer.addPass(bloomPass);

    let effectState = 0;
    const clock = new THREE.Clock();
    let time = 0;

    const effectThemes = [
        {
            name: "Lightning Storm",
            effect: "lightning",
            outer: [new THREE.Color(0x00ffff), new THREE.Color(0x4169e1), new THREE.Color(0x9400d3)],
            outerEdge: new THREE.Color(0x87cefa),
            inner: [new THREE.Color(0xff1493), new THREE.Color(0xff4500), new THREE.Color(0xffd700)],
            innerEdge: new THREE.Color(0xffd700)
        },
        {
            name: "Volcanic Shards",
            effect: "shards",
            outer: [new THREE.Color(0xffd700), new THREE.Color(0xff4500), new THREE.Color(0x8b0000)],
            outerEdge: new THREE.Color(0xff8c00),
            inner: [new THREE.Color(0xffff00), new THREE.Color(0xff6347), new THREE.Color(0xdc143c)],
            innerEdge: new THREE.Color(0xffa500),
            shardColors: [new THREE.Color(0xff8c00), new THREE.Color(0xffa500), new THREE.Color(0xffff00)]
        },
        {
            name: "Arctic Rings",
            effect: "rings",
            outer: [new THREE.Color(0x00ffff), new THREE.Color(0x87ceeb), new THREE.Color(0xb0e0e6)],
            outerEdge: new THREE.Color(0x00ffff),
            inner: [new THREE.Color(0xffffff), new THREE.Color(0xe0ffff), new THREE.Color(0xf0f8ff)],
            innerEdge: new THREE.Color(0xffffff),
            ringColors: [new THREE.Color(0x00ffff), new THREE.Color(0x87ceeb), new THREE.Color(0xffffff)]
        },
        {
            name: "Emerald Spiral",
            effect: "spiral",
            outer: [new THREE.Color(0x00ff00), new THREE.Color(0x32cd32), new THREE.Color(0x228b22)],
            outerEdge: new THREE.Color(0x98fb98),
            inner: [new THREE.Color(0xadff2f), new THREE.Color(0x9acd32), new THREE.Color(0x6b8e23)],
            innerEdge: new THREE.Color(0xadff2f),
            spiralColors: [new THREE.Color(0x00ff00), new THREE.Color(0x32cd32), new THREE.Color(0xadff2f)]
        },
        {
            name: "Solar Flare",
            effect: "flare",
            outer: [new THREE.Color(0xffa500), new THREE.Color(0xff8c00), new THREE.Color(0xff7f50)],
            outerEdge: new THREE.Color(0xffd700),
            inner: [new THREE.Color(0xffff00), new THREE.Color(0xffd700), new THREE.Color(0xffa500)],
            innerEdge: new THREE.Color(0xffff00),
            flareColors: [new THREE.Color(0xff4500), new THREE.Color(0xff6600), new THREE.Color(0xffa500), new THREE.Color(0xffff00), new THREE.Color(0xffd700)]
        }
    ];

    const effectGroups = {
        lightning: null,
        shards: new THREE.Group(),
        rings: new THREE.Group(),
        spiral: new THREE.Group(),
        flare: new THREE.Group()
    };

    scene.add(effectGroups.shards, effectGroups.rings, effectGroups.spiral, effectGroups.flare);

    const effectData = {
        lightning: { isActive: false, startTime: 0, duration: 1.0 },
        shards: { isActive: false },
        rings: { isActive: false },
        spiral: { isActive: false },
        flare: { isActive: false }
    };

    function createParticlePyramid(height, baseSize, particleCount, innerPyramid = false) {
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const particleColors = [];
        const originalColors = [];
        const twinkleFactors = [];
        const initialSizes = [];
        const baseParticleSize = innerPyramid ? 0.02 : 0.03;

        for (let i = 0; i < particleCount; i++) {
            const t = Math.random();
            const u = Math.random();
            const apex = { x: 0, y: height, z: 0 };
            const base = [
                { x: -baseSize, y: 0, z: -baseSize },
                { x: baseSize, y: 0, z: -baseSize },
                { x: baseSize, y: 0, z: baseSize },
                { x: -baseSize, y: 0, z: baseSize }
            ];
            const face = Math.floor(Math.random() * 4);
            const basePoint1 = base[face];
            const basePoint2 = base[(face + 1) % 4];
            const x = (1 - t) * ((1 - u) * basePoint1.x + u * basePoint2.x) + t * apex.x;
            const y = (1 - t) * 0 + t * height;
            const z = (1 - t) * ((1 - u) * basePoint1.z + u * basePoint2.z) + t * apex.z;
            positions.push(x, y, z);
            particleColors.push(0, 0, 0);
            originalColors.push(new THREE.Color());
            initialSizes.push(baseParticleSize);
            if (Math.random() < 0.2) {
                twinkleFactors.push(Math.random() * 2 + 1.0);
            } else {
                twinkleFactors.push(0);
            }
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(particleColors, 3));
        geometry.setAttribute('size', new THREE.Float32BufferAttribute(initialSizes, 1));

        const material = new THREE.PointsMaterial({
            vertexColors: true,
            size: baseParticleSize,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particles = new THREE.Points(geometry, material);
        return { particles, originalColors, twinkleFactors, baseParticleSize };
    }

    function updatePyramidColors(pyramidData, newColors) {
        const { particles, originalColors } = pyramidData;
        const positions = particles.geometry.attributes.position;
        const colors = particles.geometry.attributes.color;
        const height = particles.parent.userData.height;

        for (let i = 0; i < positions.count; i++) {
            const y = positions.getY(i);
            const colorPos = y / height;
            const idx = Math.min(newColors.length - 2, Math.floor(colorPos * (newColors.length - 1)));
            const c1 = newColors[idx];
            const c2 = newColors[idx + 1];
            const mix = (colorPos * (newColors.length - 1)) % 1;
            const finalColor = new THREE.Color().lerpColors(c1, c2, mix);
            colors.setXYZ(i, finalColor.r, finalColor.g, finalColor.b);
            originalColors[i].copy(finalColor);
        }
        colors.needsUpdate = true;
    }

    function setPalette(theme) {
        updatePyramidColors(outerPyramidData, theme.outer);
        outerEdges.material.color.set(theme.outerEdge);
        updatePyramidColors(innerPyramidData, theme.inner);
        innerEdges.material.color.set(theme.innerEdge);
    }

    function createPyramidEdges(height, baseSize, color) {
        const points = [];
        const apex = new THREE.Vector3(0, height, 0);
        const verts = [
            new THREE.Vector3(-baseSize, 0, -baseSize),
            new THREE.Vector3(baseSize, 0, -baseSize),
            new THREE.Vector3(baseSize, 0, baseSize),
            new THREE.Vector3(-baseSize, 0, baseSize)
        ];
        for (let i = 0; i < 4; i++) {
            points.push(apex.x, apex.y, apex.z, verts[i].x, verts[i].y, verts[i].z);
            points.push(verts[i].x, verts[i].y, verts[i].z, verts[(i + 1) % 4].x, verts[(i + 1) % 4].y, verts[(i + 1) % 4].z);
        }
        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
        const mat = new THREE.LineBasicMaterial({
            color: color,
            linewidth: 2,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        return new THREE.LineSegments(geo, mat);
    }

    const pyramidGroup = new THREE.Group();
    scene.add(pyramidGroup);

    const outerPyramidData = createParticlePyramid(2.5, 1.8, 5000);
    const outerEdges = createPyramidEdges(2.5, 1.8, new THREE.Color());
    const outerGroup = new THREE.Group();
    outerGroup.userData.height = 2.5;
    outerGroup.add(outerPyramidData.particles);

    const innerPyramidData = createParticlePyramid(1.5, 1.0, 3000, true);
    const innerEdges = createPyramidEdges(1.5, 1.0, new THREE.Color());
    const innerGroup = new THREE.Group();
    innerGroup.userData.height = 1.5;
    innerGroup.add(innerPyramidData.particles);

    pyramidGroup.add(outerGroup, outerEdges, innerGroup, innerEdges);

    const lightningMaterial = new THREE.ShaderMaterial({
        uniforms: { uTime: { value: 0 }, uLife: { value: 0 }, uFlicker: { value: 1.0 } },
        vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform float uTime, uLife, uFlicker;
            varying vec2 vUv;
            float random(vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);
            }
            float noise(vec2 st) {
                vec2 i = floor(st), f = fract(st);
                float a = random(i), b = random(i + vec2(1,0)), c = random(i + vec2(0,1)), d = random(i + vec2(1,1));
                vec2 u = f*f*(3.0-2.0*f);
                return mix(a,b,u.x) + (c-a)*u.y
